from abc import ABC, abstractmethod
from pathlib import Path
from typing import Optional


class ReportVisualizer(ABC):
    """Abstract base class for visualizing and saving report.

    Provides a complete report visualizing for:
    1. Filtering and renaming report fields
    2. Generating visualizations (implemented by subclasses)
    3. Handling output file management

    :param path_to_save: Directory path for saving visualizations
                        (default: "new_pysatl_cpd/results")
    :param file_name: Base filename for output files (default: "report")
    :param builder_result_fields: Fields to process in visualizations. Can be:
        - A set of field names to keep
        - A dict mapping {source_name: target_name} for renaming

    :ivar _path_to_save: Configured output directory
    :ivar _file_name: Base filename for outputs
    :ivar _builder_result_fields: Field selection/renaming configuration

    .. rubric:: Implementation Workflow

    1. Filters input data through :meth:`_filter_and_rename`
    2. Calls abstract :meth:`_draw` for visualization logic
    3. Returns optional processed results

    .. rubric:: Example Usage

    Basic implementation::

        class BarChartVisualizer(ReportVisualizer):
            def _draw(self, data: dict[str, float]) -> None:
                plt.bar(data.keys(), data.values())
                plt.savefig(self._path_to_save / f"{self._file_name}.png")
                plt.close()


        visualizer = BarChartVisualizer(
            path_to_save=Path("results/charts"), file_name="experiment_results", builder_result_fields={"mean", "max"}
        )
        visualizer(report_data)
    """

    def __init__(
        self,
        path_to_save: Path = Path("new_pysatl_cpd/results"),
        file_name: str = "report",
        builder_result_fields: Optional[set[str] | dict[str, str]] = None,
    ):
        self._path_to_save = path_to_save
        self._file_name = file_name
        self._builder_result_fields = builder_result_fields if builder_result_fields else set()

    def _filter_and_rename(self, report_builder_result: dict[str, float]) -> dict[str, float]:
        """Process report data by selecting and optionally renaming fields.

        :param report_builder_result: Complete report data dictionary
        :return: Filtered/renamed data dictionary
        :raises ValueError: If any configured field is missing from input

        .. note::
            - With set: preserves original field names
            - With dict: renames fields according to mapping
            - Always validates all configured fields exist
        """
        filtered_result = dict()
        for key in self._builder_result_fields:
            if key not in report_builder_result:
                raise ValueError(f"No {key} in report_builder_result")

            if isinstance(self._builder_result_fields, dict):
                filtered_result[self._builder_result_fields[key]] = report_builder_result[key]
            else:
                filtered_result[key] = report_builder_result[key]

        return filtered_result

    @abstractmethod
    def _draw(self, report_builder_result: dict[str, float]) -> Optional[dict[str, float]]:
        """Generate visualizations from report data (generated by report builder) (implemented by subclasses).

        :param report_builder_result: Filtered report data for visualization
        :return: Optional processed data dictionary

        .. rubric:: Implementation Guide

        Subclasses should:
        1. Create visualizations using the provided data
        2. Save outputs to :attr:`_path_to_save` using :attr:`_file_name`
        3. Handle their own file extensions/formatting
        4. Return any additional processed data if needed

        Example::

            def _draw(self, data: dict[str, float]) -> None:
                plt.figure(figsize=(10, 6))
                plt.plot(list(data.keys()), list(data.values()))
                plt.savefig(self._path_to_save / f"{self._file_name}.svg")
                plt.close()
        """

        ...

    def __call__(self, report_builder_result: dict[str, float]) -> Optional[dict[str, float]]:
        """Execute the full report visualization.

        :param report_builder_result: Complete report data to visualize (from report builder)
        :return: Optional processed results from visualization
        :raises ValueError: If field validation fails

        .. note::
            - Applies field filtering/renaming first
            - Delegates to concrete _draw() implementation
            - Returns any results from _draw()
        """
        filtered_report_builder_result = self._filter_and_rename(report_builder_result)
        result = self._draw(filtered_report_builder_result)
        return result
